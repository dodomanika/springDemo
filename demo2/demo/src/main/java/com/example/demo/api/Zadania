Chcemy m贸c zrobi gosowanie na komentarze
1. Dodaj nowe pola do Comment (bez getter贸w i setter贸w)
-> int upVotes;
-> int downVotes;

2. Dodaj now metod w CommentController dziaajca na adresie POST /comment/{id}/vote, kt贸ra przyjmuje w ciele zapytania:
{
"up": [boolean],
"down: [boolean]
}

3. Dodaj walidacj parametr贸w (zawsze musi by tylko jeden true, czyli zakazane kombinacje to:
-> false; false
-> true; true

W takim przypadku rzu wyjtek i przemapuj go na HTTP 400 (BAD_STATUS) dodajc stosowny reason. Walidacja niech odbywa si w metodzie kontrolera CommentController.

4. Wystaw w encji Comment dwie metody: incrementVotes() i decrementVotes(), kt贸re odpowiednio dziaaj na polach z zadania 1.


/////tuuuuuuuuuuuu
5. Dodaj now klas CommentDTO, ma zawiera te same pola co Comment, ale zamiast int upVotes i int downVotes ma zawiera jedno pole int votes (votes  = upVotes + downVotes). Wszystkie pola maj by prywatne i finalne. Wystaw konstruktor oraz gettery.

6. Zmie typ zwracanych komentarzy w GET /comment i GET /comment/{id} na CommentDTO.

7. Zmodyfikuj encj Comment tak aby r贸wnie偶 zawieraa pole int votes. Pamitaj o edycji metod z zadania 4.

8. Obejrzyj pierwsze 30 minut tego -> https://www.youtube.com/watch?v=fmLTFjhyn-k a nastpnie zmodyfikuj GET /comment aby zwracao komentarze w kolejnoci od NAJLEPIEJ ocenianych

9. Obejrzyj film do koca

10. Zrefraktoruj Comment oraz Article aby NOWE OBIEKTY tworzone byy przez konstruktor parametrowy (nie wszystkie pola w Comment nale偶y umiejscowi w konstruktorze, kt贸re nie?). Uruchom program. Nie dziaa? Dostaw pusty konstruktor (bez parametrowy). Dziaa? Hibernate tego potrzebowa.

Fajnie byoby gdyby zrobia jakie repository na github i ka偶de zadanie oddzielnie commitowaa 